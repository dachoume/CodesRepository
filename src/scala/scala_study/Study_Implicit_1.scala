package scala_study

/**
  * Created by Administrator on 2017/11/7.
  * 1、Scala中隐式转换的由来：我们想使用某一个类(B)中的特殊的方法，但是自身类(A)又没有提供这样的一个方法，
  * 通过隐式转换，可以将自身类(A)的类型转换成提供相应方法的类(B)的类型，进而调动相应的方法
  * 2、隐式转换本身可以把一个类的实例当做另外一个类的实例来使用，从使用者的角度而言，
  * 使用者使用的还是当前自己的类，但是这个类却拥有了额外的一些方法
  * 3、隐式转换的完成需要两个条件：
  * (1)首先必须有一个增强的类，在这类中含有我们需要的方法
  * (2)通过隐式转换函数将已有的类型转换为增强的类型
  * 4、隐式转换函数的命名一般这样写:前面是转换前的类型,后面是增强的(转换后)类类型 :如 int2Integer
  * 5、在隐式方法中,函数的参数就是转换前的类的实例,函数体的执行体就是创建一个增强类对象
  * 6、隐式转换中:增强类的主构造器的参数类型一般是转换前的类的类型,即增强类一般是增强已有的类,
  * 并且增强类中含有我们想要的方法
  * 7、Scala中的Predef类含有很多隐式转换的内容，比如说将Int类型通过隐式转换自动转换为Integer类型
  * 8、在隐式转换的作用域查找中，如果当前作用域没有隐式转换，编译器会到相应源或目标类型的伴生对象中查找隐式转换
  * 9、Scala一次至多只能应用一个隐式转换，如果说编译器在当前范围内寻找到了隐式转换的方式，编译器就不会向外找了
  */
object Study_Implicit_1 {
  def main(args: Array[String]): Unit = {
    val s = new SI1

    import SI1_SI1.g

    //相当于SI1_SI1.g(s).fun
    s.fun() //test


    /**
      * Scala提供了两种隐式转换的机制:
      * 第一种隐式转换的机制：隐式值：隐式值可以给方法提供参数。
      * 第二种隐式转换的机制：隐式视图：隐式视图是指把一种类型自动转换到另外一种类型，以符合表达式的要求，
      * 或使针对某类型的方法的调用能够成功。
      */


  }

}

class SI1

class SI1_Test(si: SI1) {
  def fun() = {
    println("test")
  }
}

object SI1_SI1 {
  implicit def g(si: SI1): SI1_Test = new SI1_Test(si)
}